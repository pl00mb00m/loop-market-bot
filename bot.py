print("üöÄ Iniciando el bot...")
import asyncio
import json
import datetime
import logging
import os
from html import escape
from aiogram import Bot, Dispatcher, F
from aiogram.enums import ParseMode
from aiogram.client.default import DefaultBotProperties
from aiogram.types import (
    Message, ReplyKeyboardMarkup, KeyboardButton, Location, InputMediaPhoto,
    InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
)
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.exceptions import TelegramBadRequest
from dotenv import load_dotenv

# –î–û–ë–ê–í–õ–ï–ù–û –¥–ª—è Webhooks —Å aiohttp
from aiohttp import web
from aiogram.webhook.aiohttp_server import SimpleRequestHandler, setup_application

# –î–û–ë–ê–í–õ–ï–ù–û –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ secret_token
import secrets # <-- –≠–¢–ê –°–¢–†–û–ö–ê –î–û–ë–ê–í–õ–ï–ù–ê

# üìù Configuraci√≥n del registro (logging)
logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s', handlers=[logging.StreamHandler()], force=True)
logger = logging.getLogger(__name__)

# üîß Cargar variables de entorno
load_dotenv()
print("üîç Verificando variables de entorno...")
API_TOKEN = os.getenv("BOT_TOKEN")
ADMIN_ID = os.getenv("ADMIN_ID")
print(f"BOT_TOKEN: {'‚úÖ configurado' if API_TOKEN else '‚ùå no configurado'}")
print(f"ADMIN_ID: {'‚úÖ configurado' if ADMIN_ID else '‚ùå no configurado'}")

# ‚úÖ Verificaci√≥n de variables de entorno
if not API_TOKEN:
    logger.error("‚ùå ERROR: El token del bot (BOT_TOKEN) no est√° configurado en las variables de entorno.")
    exit(1)
if not ADMIN_ID:
    logger.warning("‚ö†Ô∏è ADVERTENCIA: El ID del administrador (ADMIN_ID) no est√° configurado.")
    ADMIN_ID = None # Asegurarse de que es None si no est√° configurado
else:
    try:
        ADMIN_ID = int(ADMIN_ID)
    except ValueError:
        logger.error("‚ùå ERROR: ADMIN_ID debe ser un n√∫mero entero.")
        exit(1)

# üåê Configuraci√≥n del Webhook para Render
WEBAPP_HOST = '0.0.0.0' # –î–ª—è Render, —Å–ª—É—à–∞—Ç—å –Ω–∞ –≤—Å–µ—Ö –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞—Ö
WEBAPP_PORT = os.getenv('PORT') # Render –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –ø–æ—Ä—Ç —á–µ—Ä–µ–∑ ENV

if not WEBAPP_PORT:
    logger.error("‚ùå ERROR: La variable de entorno PORT no est√° configurada por Render.")
    exit(1)
else:
    try:
        WEBAPP_PORT = int(WEBAPP_PORT)
    except ValueError:
        logger.error("‚ùå ERROR: PORT debe ser un n√∫mero entero.")
        exit(1)

RENDER_EXTERNAL_HOSTNAME = os.getenv('RENDER_EXTERNAL_HOSTNAME')

# –ò–∑–º–µ–Ω–µ–Ω–æ: –ï—Å–ª–∏ RENDER_EXTERNAL_HOSTNAME –Ω–µ –∑–∞–¥–∞–Ω, –º—ã –Ω–µ –º–æ–∂–µ–º —Å–æ–∑–¥–∞—Ç—å URL –≤–µ–±—Ö—É–∫–∞
if not RENDER_EXTERNAL_HOSTNAME:
    logger.error("‚ùå ERROR: La variable de entorno RENDER_EXTERNAL_HOSTNAME no est√° configurada. Necesaria para WEBHOOK_URL.")
    exit(1)
else:
    # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Å–µ–∫—Ä–µ—Ç–Ω—ã–π —Ç–æ–∫–µ–Ω –¥–ª—è –≤–µ–±—Ö—É–∫–∞
    WEBHOOK_SECRET = secrets.token_urlsafe(32) # <-- –≠–¢–ê –°–¢–†–û–ö–ê –î–û–ë–ê–í–õ–ï–ù–ê
    WEBHOOK_URL = f"https://{RENDER_EXTERNAL_HOSTNAME}/webhook/{WEBHOOK_SECRET}" # <-- –≠–¢–ê –°–¢–†–û–ö–ê –ò–ó–ú–ï–ù–ï–ù–ê
    # –í–∞–∂–Ω–æ: WEBHOOK_PATH = /webhook/{WEBHOOK_SECRET}

# ü§ñ Inicializaci√≥n del bot y dispatcher
default_props = DefaultBotProperties(parse_mode=ParseMode.HTML)
bot = Bot(token=API_TOKEN, default=default_props)
storage = MemoryStorage() # –ò—Å–ø–æ–ª—å–∑—É–µ–º MemoryStorage, –¥–ª—è –±–æ–ª—å—à–∏—Ö –±–æ—Ç–æ–≤ –º–æ–∂–Ω–æ —Ä–∞—Å—Å–º–æ—Ç—Ä–µ—Ç—å Redis
dp = Dispatcher(storage=storage)


# üìù Diccionarios para almacenar –¥–∞–Ω–Ω—ã–µ (persistentes entre reinicios si se guarda/carga)
user_data_file = 'user_data.json'
listings_file = 'listings.json'
users_data = {}
listings = {}

async def load_user_data():
    global users_data
    if os.path.exists(user_data_file):
        with open(user_data_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
            users_data = {int(k): v for k, v in data.items()}
            logger.info(f"‚úÖ Datos de usuario cargados desde {user_data_file}")
    else:
        users_data = {}
        logger.info(f"üÜï {user_data_file} no encontrado, iniciando con datos de usuario vac√≠os.")

async def save_user_data():
    with open(user_data_file, 'w', encoding='utf-8') as f:
        json.dump(users_data, f, ensure_ascii=False, indent=4)
    logger.info(f"üíæ Datos de usuario guardados en {user_data_file}")

async def load_listings():
    global listings
    if os.path.exists(listings_file):
        with open(listings_file, 'r', encoding='utf-8') as f:
            data = json.load(f)
            listings = {k: v for k, v in data.items()}
            # Convertir las fechas de expiraci√≥n de nuevo a objetos datetime
            for listing_id, listing_info in listings.items():
                if 'expires_at' in listing_info and isinstance(listing_info['expires_at'], str):
                    try:
                        listing_info['expires_at'] = datetime.datetime.fromisoformat(listing_info['expires_at'])
                    except ValueError:
                        logger.error(f"‚ùå Error al parsear fecha para {listing_id}: {listing_info['expires_at']}")
                        listing_info['expires_at'] = None # O manejar el error de otra forma
            logger.info(f"‚úÖ Anuncios cargados desde {listings_file}")
    else:
        listings = {}
        logger.info(f"üÜï {listings_file} no encontrado, iniciando con anuncios vac√≠os.")

async def save_listings():
    with open(listings_file, 'w', encoding='utf-8') as f:
        # Convertir objetos datetime a strings ISO para JSON
        json_serializable_listings = {}
        for listing_id, listing_info in listings.items():
            serializable_info = listing_info.copy()
            if 'expires_at' in serializable_info and isinstance(serializable_info['expires_at'], datetime.datetime):
                serializable_info['expires_at'] = serializable_info['expires_at'].isoformat()
            json_serializable_listings[listing_id] = serializable_info
        json.dump(json_serializable_listings, f, ensure_ascii=False, indent=4)
    logger.info(f"üíæ Anuncios guardados en {listings_file}")


# üìö Estados para FSM
class Form(StatesGroup):
    title = State()
    description = State()
    category = State()
    price = State()
    photos = State()
    location = State()
    contact = State()
    terms_agreed = State()
    confirm_publish = State()
    edit_field = State()
    edit_item_id = State()
    edit_title = State()
    edit_description = State()
    edit_category = State()
    edit_price = State()
    edit_photos = State()
    edit_location = State()
    edit_contact = State()
    confirm_delete = State()
    set_duration = State()


# ‚å®Ô∏è Teclados
main_keyboard = ReplyKeyboardMarkup(
    keyboard=[
        [KeyboardButton(text="‚ûï Publicar Anuncio"), KeyboardButton(text="üîç Mis Anuncios")],
        [KeyboardButton(text="‚öôÔ∏è Configuraci√≥n")]
    ],
    resize_keyboard=True,
    input_field_placeholder="Seleccione una opci√≥n"
)

# ... (–û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –æ—Å—Ç–∞–ª–∏—Å—å –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
def get_main_keyboard_admin():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="‚ûï Publicar Anuncio"), KeyboardButton(text="üîç Mis Anuncios")],
            [KeyboardButton(text="‚öôÔ∏è Configuraci√≥n"), KeyboardButton(text="üìä Admin Panel")] # –î–æ–±–∞–≤–ª–µ–Ω–∞ –∫–Ω–æ–ø–∫–∞ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏
        ],
        resize_keyboard=True,
        input_field_placeholder="Seleccione una opci√≥n"
    )


# ------------------------------ Funciones de ayuda ------------------------------
def generate_listing_id():
    """Genera un ID √∫nico basado en el timestamp."""
    return str(int(datetime.datetime.now().timestamp()))

def format_listing_message(listing_id, listing_info, include_contact=False):
    """Formatea la informaci√≥n del anuncio en un mensaje."""
    title = escape(listing_info.get('title', 'N/A'))
    description = escape(listing_info.get('description', 'N/A'))
    category = escape(listing_info.get('category', 'N/A'))
    price = listing_info.get('price', 'N/A')
    location_str = escape(listing_info.get('location_name', 'No especificada'))

    expires_at = listing_info.get('expires_at')
    expiry_info = ""
    if expires_at and isinstance(expires_at, datetime.datetime):
        remaining_time = expires_at - datetime.datetime.now()
        if remaining_time.total_seconds() > 0:
            days = remaining_time.days
            hours = remaining_time.seconds // 3600
            minutes = (remaining_time.seconds % 3600) // 60
            if days > 0:
                expiry_info = f"Vigencia: {days}d {hours}h {minutes}m"
            else:
                expiry_info = f"Vigencia: {hours}h {minutes}m"
        else:
            expiry_info = "Expirado"
    else:
        expiry_info = "Vigencia: Indefinido" # Fallback si no hay fecha o es inv√°lida

    message_text = (
        f"<b>Anuncio #{listing_id}</b>\n"
        f"<b>T√≠tulo:</b> {title}\n"
        f"<b>Descripci√≥n:</b> {description}\n"
        f"<b>Categor√≠a:</b> {category}\n"
        f"<b>Precio:</b> ${price}\n"
        f"<b>Ubicaci√≥n:</b> {location_str}\n"
        f"<i>{expiry_info}</i>"
    )

    if include_contact:
        contact = escape(listing_info.get('contact', 'No especificado'))
        message_text += f"\n<b>Contacto:</b> {contact}"
    
    return message_text

async def display_item_card(chat_id, listing_id, caller_is_edit=False, is_admin_view=False):
    """Muestra la tarjeta del anuncio con sus opciones."""
    listing = listings.get(listing_id)
    if not listing:
        await bot.send_message(chat_id, "‚ùó Anuncio no encontrado.")
        return

    photos = listing.get('photos', [])
    caption = format_listing_message(listing_id, listing, include_contact=True)

    keyboard = InlineKeyboardMarkup(inline_keyboard=[])
    
    # Botones para usuario/administrador
    if is_admin_view:
        keyboard.inline_keyboard.append([
            InlineKeyboardButton(text="üìù Editar", callback_data=f"edit_listing:{listing_id}"),
            InlineKeyboardButton(text="‚ùå Eliminar", callback_data=f"delete_listing:{listing_id}")
        ])
        keyboard.inline_keyboard.append([
            InlineKeyboardButton(text="‚è≥ Establecer vigencia", callback_data=f"set_duration:{listing_id}")
        ])
        keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è Volver al Panel Admin", callback_data="back_to_admin_panel")])
    elif caller_is_edit: # Si el usuario est√° editando su propio anuncio
        keyboard.inline_keyboard.append([
            InlineKeyboardButton(text="üìù Editar", callback_data=f"edit_listing:{listing_id}"),
            InlineKeyboardButton(text="‚ùå Eliminar", callback_data=f"delete_listing:{listing_id}")
        ])
        keyboard.inline_keyboard.append([
            InlineKeyboardButton(text="‚è≥ Establecer vigencia", callback_data=f"set_duration:{listing_id}")
        ])
        keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è Mis Anuncios", callback_data="my_listings")])

    else: # Vista p√∫blica del anuncio
        # Si es el propietario del anuncio, mostrar botones de edici√≥n
        if listing.get('user_id') == chat_id:
             keyboard.inline_keyboard.append([
                InlineKeyboardButton(text="üìù Editar", callback_data=f"edit_listing:{listing_id}"),
                InlineKeyboardButton(text="‚ùå Eliminar", callback_data=f"delete_listing:{listing_id}")
            ])
             keyboard.inline_keyboard.append([
                InlineKeyboardButton(text="‚è≥ Establecer vigencia", callback_data=f"set_duration:{listing_id}")
            ])
        
        # Bot√≥n para ir a la ubicaci√≥n (si existe)
        if 'location_latitude' in listing and 'location_longitude' in listing:
            location_url = f"http://maps.google.com/maps?q={listing['location_latitude']},{listing['location_longitude']}"
            keyboard.inline_keyboard.append([
                InlineKeyboardButton(text="üìç Ver en Mapa", url=location_url)
            ])
        
        # Bot√≥n de contacto directo
        if listing.get('contact'):
            keyboard.inline_keyboard.append([
                InlineKeyboardButton(text="üí¨ Contactar", url=f"https://t.me/{listing['contact']}")
            ])
        
        keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è Volver", callback_data="back_to_main")])


    if photos:
        media = []
        for i, photo_id in enumerate(photos):
            if i == 0: # Primera foto con caption
                media.append(InputMediaPhoto(media=photo_id, caption=caption))
            else: # Resto de fotos sin caption
                media.append(InputMediaPhoto(media=photo_id))
        
        try:
            await bot.send_media_group(chat_id, media=media)
            # El teclado se env√≠a con un mensaje separado si hay fotos,
            # ya que send_media_group no soporta reply_markup directamente.
            await bot.send_message(chat_id, "Opciones del anuncio:", reply_markup=keyboard)
        except TelegramBadRequest as e:
            logger.error(f"‚ùå Error al enviar grupo de fotos o mensaje: {e}")
            await bot.send_message(chat_id, caption, reply_markup=keyboard) # Enviar solo texto si falla
    else:
        await bot.send_message(chat_id, caption, reply_markup=keyboard)

def get_edit_field_keyboard(listing_id):
    keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üìù T√≠tulo", callback_data=f"edit_field_type:{listing_id}:title")],
        [InlineKeyboardButton(text="üìù Descripci√≥n", callback_data=f"edit_field_type:{listing_id}:description")],
        [InlineKeyboardButton(text="üìù Categor√≠a", callback_data=f"edit_field_type:{listing_id}:category")],
        [InlineKeyboardButton(text="üìù Precio", callback_data=f"edit_field_type:{listing_id}:price")],
        [InlineKeyboardButton(text="üì∏ Fotos", callback_data=f"edit_field_type:{listing_id}:photos")],
        [InlineKeyboardButton(text="üìç Ubicaci√≥n", callback_data=f"edit_field_type:{listing_id}:location")],
        [InlineKeyboardButton(text="üìû Contacto", callback_data=f"edit_field_type:{listing_id}:contact")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è Volver al Anuncio", callback_data=f"view_listing_edit:{listing_id}")]
    ])
    return keyboard

def get_confirm_delete_keyboard(listing_id):
    return InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚úÖ S√≠, eliminar", callback_data=f"confirm_delete_yes:{listing_id}")],
        [InlineKeyboardButton(text="‚ùå No, cancelar", callback_data=f"confirm_delete_no:{listing_id}")]
    ])

def get_expires_at_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìÖ 3 d√≠as"), KeyboardButton(text="üìÖ 5 d√≠as")],
            [KeyboardButton(text="üóìÔ∏è Sin fecha de caducidad")]
        ],
        resize_keyboard=True,
        one_time_keyboard=True
    )

# ------------------------------ Handlers ------------------------------

@dp.message(Command("start"))
async def command_start_handler(message: Message, state: FSMContext) -> None:
    await state.clear()
    user_id = message.from_user.id
    username = message.from_user.username
    full_name = message.from_user.full_name

    if user_id not in users_data:
        users_data[user_id] = {
            'username': username,
            'full_name': full_name,
            'first_access': datetime.datetime.now().isoformat()
        }
        await save_user_data()
        logger.info(f"üÜï Nuevo usuario registrado: {user_id} ({full_name})")
        await message.answer(
            f"¬°Hola {escape(message.from_user.full_name)}! üëã\n"
            "Bienvenido al bot de compra y venta. Aqu√≠ puedes publicar tus anuncios y encontrar lo que buscas.",
            reply_markup=main_keyboard
        )
        if ADMIN_ID and user_id != ADMIN_ID: # –û–ø–æ–≤–µ—Å—Ç–∏—Ç—å –∞–¥–º–∏–Ω–∞ –æ –Ω–æ–≤–æ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ
            await bot.send_message(ADMIN_ID, f"üéâ Nuevo usuario: {full_name} (@{username if username else 'N/A'}) (ID: {user_id})")
    else:
        users_data[user_id]['username'] = username # –û–±–Ω–æ–≤–ª—è–µ–º –Ω–∏–∫–Ω–µ–π–º –Ω–∞ —Å–ª—É—á–∞–π –∏–∑–º–µ–Ω–µ–Ω–∏—è
        users_data[user_id]['full_name'] = full_name # –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª–Ω–æ–µ –∏–º—è
        await save_user_data()
        await message.answer(
            f"¬°Hola de nuevo {escape(message.from_user.full_name)}! üëã",
            reply_markup=main_keyboard if user_id != ADMIN_ID else get_main_keyboard_admin()
        )
    logger.info(f"‚û°Ô∏è Usuario {user_id} inici√≥ el bot.")


@dp.message(F.text == "‚ûï Publicar Anuncio")
async def start_new_listing(message: Message, state: FSMContext):
    await state.clear()
    await state.set_state(Form.title)
    await message.answer("¬°Empecemos! ¬øCu√°l es el t√≠tulo de tu anuncio? (Ej: 'IPhone 15 Pro Max 256GB')")
    logger.info(f"‚û°Ô∏è Usuario {message.from_user.id} inici√≥ la publicaci√≥n de un anuncio.")

@dp.message(Form.title)
async def process_title(message: Message, state: FSMContext):
    if len(message.text) > 100:
        await message.answer("‚ùó El t√≠tulo es demasiado largo. Por favor, que no exceda 100 caracteres.")
        return
    await state.update_data(title=message.text)
    await state.set_state(Form.description)
    await message.answer("Ahora, una descripci√≥n detallada. (Ej: 'Como nuevo, con garant√≠a, incluye accesorios')")

@dp.message(Form.description)
async def process_description(message: Message, state: FSMContext):
    if len(message.text) > 1000:
        await message.answer("‚ùó La descripci√≥n es demasiado larga. Por favor, que no exceda 1000 caracteres.")
        return
    await state.update_data(description=message.text)
    await state.set_state(Form.category)
    await message.answer(
        "¬øEn qu√© categor√≠a encaja tu anuncio?",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[
                [KeyboardButton(text="üì± Electr√≥nica"), KeyboardButton(text="üëó Moda")],
                [KeyboardButton(text="üè° Hogar"), KeyboardButton(text="üöó Veh√≠culos")],
                [KeyboardButton(text="üìö Libros"), KeyboardButton(text="üèÄ Deportes")],
                [KeyboardButton(text="üíº Servicios"), KeyboardButton(text="‚ú® Otros")]
            ],
            resize_keyboard=True, one_time_keyboard=True
        )
    )

@dp.message(Form.category, F.text.in_({"üì± Electr√≥nica", "üëó Moda", "üè° Hogar", "üöó Veh√≠culos", "üìö Libros", "üèÄ Deportes", "üíº Servicios", "‚ú® Otros"}))
async def process_category(message: Message, state: FSMContext):
    await state.update_data(category=message.text)
    await state.set_state(Form.price)
    await message.answer("¬øCu√°l es el precio? (Ej: '150.50' o 'Negociable')", reply_markup=None) # Quitar teclado anterior

@dp.message(Form.category)
async def process_category_invalid(message: Message):
    await message.answer("‚ùó Por favor, seleccione una categor√≠a de la lista.")

@dp.message(Form.price)
async def process_price(message: Message, state: FSMContext):
    price_text = message.text.replace(',', '.').strip()
    if price_text.lower() == 'negociable':
        await state.update_data(price='Negociable')
    else:
        try:
            price = float(price_text)
            if price <= 0:
                raise ValueError
            await state.update_data(price=f"{price:.2f}") # Formatear a 2 decimales
        except ValueError:
            await message.answer("‚ùó Formato de precio inv√°lido. Por favor, introduzca un n√∫mero (ej: '150.50') o 'Negociable'.")
            return
    await state.update_data(photos=[]) # Inicializar lista de fotos
    await state.set_state(Form.photos)
    await message.answer(
        "¬°Perfecto! Ahora, env√≠a hasta 10 fotos de tu art√≠culo. Puedes enviar varias a la vez. Cuando termines, env√≠a 'Listo'.",
        reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="Listo")]], resize_keyboard=True)
    )

@dp.message(Form.photos, F.photo)
async def process_photos(message: Message, state: FSMContext):
    data = await state.get_data()
    photos = data.get('photos', [])
    
    if len(photos) >= 10:
        await message.answer("‚ùó Ya tienes el m√°ximo de 10 fotos. Por favor, env√≠a 'Listo'.")
        return
    
    # Tomar la ID de la foto de la mayor resoluci√≥n
    file_id = message.photo[-1].file_id
    photos.append(file_id)
    await state.update_data(photos=photos)
    await message.answer(f"‚úÖ Foto a√±adida. Tienes {len(photos)}/{10} fotos. Env√≠a m√°s o 'Listo'.")


@dp.message(Form.photos, F.text == "Listo")
async def process_photos_done(message: Message, state: FSMContext):
    data = await state.get_data()
    photos = data.get('photos', [])
    if not photos:
        await message.answer("‚ùó Por favor, env√≠a al menos una foto antes de continuar, o contin√∫a si no tienes fotos.")
        # Opcional: permitir continuar sin fotos, si es el caso
        # await message.answer("¬øEst√°s seguro de que quieres continuar sin fotos? Si es as√≠, env√≠a 'S√≠, sin fotos'.")
        # await state.set_state(Form.confirm_no_photos) # Nuevo estado si se permite sin fotos
        return

    await state.set_state(Form.location)
    await message.answer(
        "Ahora, por favor, comparte tu ubicaci√≥n o escribe la zona. (Ej: 'Guayaquil', 'Samborond√≥n', 'Quito')",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="Compartir mi ubicaci√≥n actual", request_location=True)]],
            resize_keyboard=True, one_time_keyboard=True
        )
    )

@dp.message(Form.location, F.location)
async def process_location_by_coords(message: Message, state: FSMContext):
    await state.update_data(
        location_latitude=message.location.latitude,
        location_longitude=message.location.longitude,
        location_name="Ubicaci√≥n compartida por GPS" # Puedes intentar geocodificar para obtener nombre
    )
    await state.set_state(Form.contact)
    await message.answer(
        "¬°Excelente! Ahora, ingresa tu usuario de Telegram para contacto. (Ej: @tu_usuario) o tu n√∫mero de tel√©fono.",
        reply_markup=None # Remover teclado anterior
    )

@dp.message(Form.location)
async def process_location_by_text(message: Message, state: FSMContext):
    if len(message.text) > 100:
        await message.answer("‚ùó El nombre de la ubicaci√≥n es demasiado largo. Por favor, que no exceda 100 caracteres.")
        return
    await state.update_data(location_name=message.text)
    await state.update_data(location_latitude=None, location_longitude=None) # Asegurarse que no hay coords si es texto
    await state.set_state(Form.contact)
    await message.answer(
        "¬°Excelente! Ahora, ingresa tu usuario de Telegram para contacto. (Ej: @tu_usuario) o tu n√∫mero de tel√©fono.",
        reply_markup=None
    )


@dp.message(Form.contact)
async def process_contact(message: Message, state: FSMContext):
    contact_info = message.text.strip()
    if not contact_info:
        await message.answer("‚ùó Por favor, ingrese su informaci√≥n de contacto.")
        return
    if len(contact_info) > 100:
        await message.answer("‚ùó La informaci√≥n de contacto es demasiado larga. Por favor, que no exceda 100 caracteres.")
        return
    await state.update_data(contact=contact_info)
    await state.set_state(Form.terms_agreed)
    await message.answer(
        "Antes de publicar, por favor, acepta nuestros t√©rminos y condiciones: [enlace a T&C](https://telegra.ph/T%C3%A9rminos-y-Condiciones-05-18) (Este es un ejemplo, reempl√°zalo con tus T&C reales).\n\n"
        "¬øAceptas los t√©rminos y condiciones?",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚úÖ Acepto los t√©rminos")]],
            resize_keyboard=True, one_time_keyboard=True
        )
    )

@dp.message(Form.terms_agreed, F.text == "‚úÖ Acepto los t√©rminos")
async def process_terms_agreed(message: Message, state: FSMContext):
    data = await state.get_data()
    
    # Generar un ID √∫nico para el anuncio
    listing_id = generate_listing_id()
    
    # Guardar todos los datos del formulario junto con el ID del usuario y la fecha
    listings[listing_id] = {
        'user_id': message.from_user.id,
        'username': message.from_user.username,
        'full_name': message.from_user.full_name,
        'published_at': datetime.datetime.now().isoformat(), # Fecha de publicaci√≥n
        'status': 'active', # Estado inicial del anuncio
        **data # Desempaquetar todos los datos del formulario
    }
    
    # Establecer duraci√≥n por defecto a 3 –¥–Ω—è
    listings[listing_id]['expires_at'] = datetime.datetime.now() + datetime.timedelta(days=3)

    await save_listings() # Guardar los anuncios

    await state.set_state(Form.confirm_publish)
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=False) # Mostrar el anuncio creado

    await message.answer(
        "¬°Tu anuncio est√° casi listo! Confirma para publicarlo o puedes editarlo.",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üöÄ Publicar Anuncio", callback_data=f"publish_confirm:{listing_id}")],
            [InlineKeyboardButton(text="üìù Editar Anuncio", callback_data=f"edit_listing:{listing_id}")]
        ])
    )
    logger.info(f"üìù Anuncio {listing_id} creado por {message.from_user.id}, esperando confirmaci√≥n.")

@dp.message(Form.terms_agreed)
async def process_terms_invalid(message: Message):
    await message.answer("‚ùó Por favor, debe aceptar los t√©rminos para continuar.")

@dp.callback_query(F.data.startswith("publish_confirm:"))
async def confirm_publish_listing(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    listing_id = callback_query.data.split(":")[1]

    if listing_id not in listings:
        await bot.send_message(callback_query.from_user.id, "‚ùó Anuncio no encontrado o ya publicado.")
        await state.clear()
        await callback_query.message.delete_reply_markup()
        return

    # Aqu√≠ podr√≠amos hacer algo con el estado 'confirm_publish' si fuera necesario,
    # pero como ya est√° todo en `listings`, solo confirmamos.
    listings[listing_id]['status'] = 'active' # Aseguramos que el estado es activo
    await save_listings()

    await bot.send_message(
        callback_query.from_user.id,
        f"‚úÖ ¬°Tu anuncio #{listing_id} ha sido publicado exitosamente!\n"
        "Puedes verlo en 'üîç Mis Anuncios'.",
        reply_markup=main_keyboard if callback_query.from_user.id != ADMIN_ID else get_main_keyboard_admin()
    )
    await callback_query.message.delete_reply_markup() # Eliminar botones de confirmaci√≥n
    await state.clear()
    logger.info(f"‚úÖ Anuncio {listing_id} publicado por {callback_query.from_user.id}.")

# ------------------------------ Mis Anuncios ------------------------------

@dp.message(F.text == "üîç Mis Anuncios")
@dp.callback_query(F.data == "my_listings")
async def show_my_listings(update: Message | CallbackQuery, state: FSMContext):
    await state.clear()
    user_id = update.from_user.id
    user_listings = {lid: info for lid, info in listings.items() if info.get('user_id') == user_id}

    if isinstance(update, CallbackQuery):
        await update.answer()
        # await update.message.delete_reply_markup() # Opcional: —É–¥–∞–ª–∏—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –∫–Ω–æ–ø–∫–∏

    if not user_listings:
        if isinstance(update, Message):
            await update.answer("No tienes anuncios publicados a√∫n. ¬°Publica uno con '‚ûï Publicar Anuncio'!", reply_markup=main_keyboard)
        else: # CallbackQuery
            await update.message.answer("No tienes anuncios publicados a√∫n. ¬°Publica uno con '‚ûï Publicar Anuncio'!", reply_markup=main_keyboard)
        logger.info(f"‚û°Ô∏è Usuario {user_id} no tiene anuncios.")
        return

    message_text = "Mis anuncios:\n"
    keyboard = InlineKeyboardMarkup(inline_keyboard=[])

    sorted_listings = sorted(user_listings.items(), key=lambda item: item[1].get('published_at', ''), reverse=True)

    for listing_id, info in sorted_listings:
        title = escape(info.get('title', 'N/A'))
        status_icon = "üü¢" if info.get('status') == 'active' else "üî¥" # A√±adir icono de estado
        message_text += f"{status_icon} Anuncio #{listing_id}: {title}\n"
        keyboard.inline_keyboard.append([
            InlineKeyboardButton(text=f"Ver Anuncio #{listing_id}", callback_data=f"view_listing_edit:{listing_id}")
        ])
    
    keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è Men√∫ Principal", callback_data="back_to_main")])

    if isinstance(update, Message):
        await update.answer(message_text, reply_markup=keyboard)
    else: # CallbackQuery
        try:
            await update.message.edit_text(message_text, reply_markup=keyboard)
        except TelegramBadRequest: # Si el texto no cambi√≥, solo actualizar el markup
            await update.message.answer(message_text, reply_markup=keyboard) # Enviar como nuevo mensaje si falla la edici√≥n
    logger.info(f"‚û°Ô∏è Usuario {user_id} vio sus anuncios.")

@dp.callback_query(F.data.startswith("view_listing_edit:"))
async def view_listing_from_edit(callback_query: CallbackQuery):
    await callback_query.answer()
    listing_id = callback_query.data.split(":")[1]
    await display_item_card(callback_query.from_user.id, listing_id, caller_is_edit=True)
    logger.info(f"‚û°Ô∏è Usuario {callback_query.from_user.id} viendo anuncio {listing_id} para edici√≥n.")


# ------------------------------ Edici√≥n de Anuncios ------------------------------

@dp.callback_query(F.data.startswith("edit_listing:"))
async def edit_listing(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    listing_id = callback_query.data.split(":")[1]
    
    if listing_id not in listings or listings[listing_id]['user_id'] != callback_query.from_user.id:
        if callback_query.from_user.id != ADMIN_ID: # –ü—Ä–æ–≤–µ—Ä–∫–∞ –∞–¥–º–∏–Ω–∞
            await bot.send_message(callback_query.from_user.id, "‚ùó No tienes permiso para editar este anuncio.")
            return

    await state.update_data(selected_item_id=listing_id)
    await state.set_state(Form.edit_field)
    await callback_query.message.answer(
        f"¬øQu√© campo del anuncio #{listing_id} deseas editar?",
        reply_markup=get_edit_field_keyboard(listing_id)
    )
    logger.info(f"‚û°Ô∏è Usuario {callback_query.from_user.id} inici√≥ edici√≥n del anuncio {listing_id}.")


@dp.callback_query(F.data.startswith("edit_field_type:"))
async def ask_for_edit_value(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    _, listing_id, field_type = callback_query.data.split(":")
    
    await state.update_data(selected_item_id=listing_id, field_to_edit=field_type)

    if field_type == 'title':
        await state.set_state(Form.edit_title)
        await callback_query.message.answer(f"Ingresa el nuevo t√≠tulo para el anuncio #{listing_id}:")
    elif field_type == 'description':
        await state.set_state(Form.edit_description)
        await callback_query.message.answer(f"Ingresa la nueva descripci√≥n para el anuncio #{listing_id}:")
    elif field_type == 'category':
        await state.set_state(Form.edit_category)
        await callback_query.message.answer(
            f"Selecciona la nueva categor√≠a para el anuncio #{listing_id}:",
            reply_markup=ReplyKeyboardMarkup(
                keyboard=[
                    [KeyboardButton(text="üì± Electr√≥nica"), KeyboardButton(text="üëó Moda")],
                    [KeyboardButton(text="üè° Hogar"), KeyboardButton(text="üöó Veh√≠culos")],
                    [KeyboardButton(text="üìö Libros"), KeyboardButton(text="üèÄ Deportes")],
                    [KeyboardButton(text="üíº Servicios"), KeyboardButton(text="‚ú® Otros")]
                ],
                resize_keyboard=True, one_time_keyboard=True
            )
        )
    elif field_type == 'price':
        await state.set_state(Form.edit_price)
        await callback_query.message.answer(f"Ingresa el nuevo precio para el anuncio #{listing_id}: (Ej: '150.50' o 'Negociable')")
    elif field_type == 'photos':
        await state.update_data(photos=[]) # Resetear fotos para una nueva carga
        await state.set_state(Form.edit_photos)
        await callback_query.message.answer(
            f"Env√≠a hasta 10 fotos nuevas para el anuncio #{listing_id}. Cuando termines, env√≠a 'Listo'.\n"
            "Las fotos anteriores ser√°n reemplazadas.",
            reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="Listo")]], resize_keyboard=True)
        )
    elif field_type == 'location':
        await state.set_state(Form.edit_location)
        await callback_query.message.answer(
            f"Ingresa la nueva ubicaci√≥n o comparte tu ubicaci√≥n actual para el anuncio #{listing_id}:",
            reply_markup=ReplyKeyboardMarkup(
                keyboard=[[KeyboardButton(text="Compartir mi ubicaci√≥n actual", request_location=True)]],
                resize_keyboard=True, one_time_keyboard=True
            )
        )
    elif field_type == 'contact':
        await state.set_state(Form.edit_contact)
        await callback_query.message.answer(f"Ingresa la nueva informaci√≥n de contacto para el anuncio #{listing_id}: (Ej: @tu_usuario o tu n√∫mero)")
    logger.info(f"‚û°Ô∏è Usuario {callback_query.from_user.id} seleccion√≥ editar {field_type} para anuncio {listing_id}.")


# Handlers para los campos de edici√≥n espec√≠ficos
@dp.message(Form.edit_title)
async def process_edit_title(message: Message, state: FSMContext):
    if len(message.text) > 100:
        await message.answer("‚ùó El t√≠tulo es demasiado largo. Por favor, que no exceda 100 caracteres.")
        return
    data = await state.get_data()
    listing_id = data.get('selected_item_id')
    listings[listing_id]['title'] = message.text
    await save_listings()
    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ el t√≠tulo del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()

@dp.message(Form.edit_description)
async def process_edit_description(message: Message, state: FSMContext):
    if len(message.text) > 1000:
        await message.answer("‚ùó La descripci√≥n es demasiado larga. Por favor, que no exceda 1000 caracteres.")
        return
    data = await state.get_data()
    listing_id = data.get('selected_item_id')
    listings[listing_id]['description'] = message.text
    await save_listings()
    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ la descripci√≥n del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()

@dp.message(Form.edit_category, F.text.in_({"üì± Electr√≥nica", "üëó Moda", "üè° Hogar", "üöó Veh√≠culos", "üìö Libros", "üèÄ Deportes", "üíº Servicios", "‚ú® Otros"}))
async def process_edit_category(message: Message, state: FSMContext):
    data = await state.get_data()
    listing_id = data.get('selected_item_id')
    listings[listing_id]['category'] = message.text
    await save_listings()
    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ la categor√≠a del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()

@dp.message(Form.edit_category)
async def process_edit_category_invalid(message: Message):
    await message.answer("‚ùó Por favor, seleccione una categor√≠a de la lista.")

@dp.message(Form.edit_price)
async def process_edit_price(message: Message, state: FSMContext):
    price_text = message.text.replace(',', '.').strip()
    if price_text.lower() == 'negociable':
        data = await state.get_data()
        listing_id = data.get('selected_item_id')
        listings[listing_id]['price'] = 'Negociable'
    else:
        try:
            price = float(price_text)
            if price <= 0:
                raise ValueError
            data = await state.get_data()
            listing_id = data.get('selected_item_id')
            listings[listing_id]['price'] = f"{price:.2f}"
        except ValueError:
            await message.answer("‚ùó Formato de precio inv√°lido. Por favor, introduzca un n√∫mero (ej: '150.50') o 'Negociable'.")
            return
    await save_listings()
    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ el precio del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()

@dp.message(Form.edit_photos, F.photo)
async def process_edit_photos(message: Message, state: FSMContext):
    data = await state.get_data()
    photos = data.get('photos', [])
    
    if len(photos) >= 10:
        await message.answer("‚ùó Ya tienes el m√°ximo de 10 fotos. Por favor, env√≠a 'Listo'.")
        return
    
    file_id = message.photo[-1].file_id
    photos.append(file_id)
    await state.update_data(photos=photos)
    await message.answer(f"‚úÖ Foto a√±adida. Tienes {len(photos)}/{10} fotos. Env√≠a m√°s o 'Listo'.")

@dp.message(Form.edit_photos, F.text == "Listo")
async def process_edit_photos_done(message: Message, state: FSMContext):
    data = await state.get_data()
    listing_id = data.get('selected_item_id')
    photos = data.get('photos', [])

    if not photos:
        await message.answer("‚ùó Por favor, env√≠a al menos una foto antes de continuar con la edici√≥n de fotos.")
        return
    
    listings[listing_id]['photos'] = photos # Reemplazar fotos existentes
    await save_listings()
    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ las fotos del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()

@dp.message(Form.edit_location, F.location)
async def process_edit_location_by_coords(message: Message, state: FSMContext):
    data = await state.get_data()
    listing_id = data.get('selected_item_id')
    listings[listing_id]['location_latitude'] = message.location.latitude
    listings[listing_id]['location_longitude'] = message.location.longitude
    listings[listing_id]['location_name'] = "Ubicaci√≥n compartida por GPS"
    await save_listings()
    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ la ubicaci√≥n (GPS) del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()

@dp.message(Form.edit_location)
async def process_edit_location_by_text(message: Message, state: FSMContext):
    if len(message.text) > 100:
        await message.answer("‚ùó El nombre de la ubicaci√≥n es demasiado largo. Por favor, que no exceda 100 caracteres.")
        return
    data = await state.get_data()
    listing_id = data.get('selected_item_id')
    listings[listing_id]['location_name'] = message.text
    listings[listing_id]['location_latitude'] = None # Resetear coords si se usa texto
    listings[listing_id]['location_longitude'] = None
    await save_listings()
    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ la ubicaci√≥n (texto) del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()

@dp.message(Form.edit_contact)
async def process_edit_contact(message: Message, state: FSMContext):
    contact_info = message.text.strip()
    if not contact_info:
        await message.answer("‚ùó Por favor, ingrese su informaci√≥n de contacto.")
        return
    if len(contact_info) > 100:
        await message.answer("‚ùó La informaci√≥n de contacto es demasiado larga. Por favor, que no exceda 100 caracteres.")
        return
    data = await state.get_data()
    listing_id = data.get('selected_item_id')
    listings[listing_id]['contact'] = contact_info
    await save_listings()
    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ el contacto del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()

# ------------------------------ Eliminar Anuncios ------------------------------

@dp.callback_query(F.data.startswith("delete_listing:"))
async def confirm_delete_listing(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    listing_id = callback_query.data.split(":")[1]
    
    if listing_id not in listings or (listings[listing_id]['user_id'] != callback_query.from_user.id and callback_query.from_user.id != ADMIN_ID):
        await bot.send_message(callback_query.from_user.id, "‚ùó No tienes permiso para eliminar este anuncio.")
        return

    await state.update_data(selected_item_id=listing_id)
    await state.set_state(Form.confirm_delete)
    await callback_query.message.answer(
        f"¬øEst√°s seguro de que quieres eliminar el anuncio #{listing_id}?",
        reply_markup=get_confirm_delete_keyboard(listing_id)
    )
    logger.info(f"‚û°Ô∏è Usuario {callback_query.from_user.id} inici√≥ proceso de eliminaci√≥n para anuncio {listing_id}.")

@dp.callback_query(F.data.startswith("confirm_delete_yes:"))
async def execute_delete_listing(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    listing_id = callback_query.data.split(":")[1]

    if listing_id not in listings or (listings[listing_id]['user_id'] != callback_query.from_user.id and callback_query.from_user.id != ADMIN_ID):
        await bot.send_message(callback_query.from_user.id, "‚ùó No tienes permiso para eliminar este anuncio o ya fue eliminado.")
        await state.clear()
        return

    del listings[listing_id]
    await save_listings()
    await state.clear()
    await callback_query.message.edit_text(f"‚úÖ Anuncio #{listing_id} eliminado exitosamente.")
    logger.info(f"‚ùå Usuario {callback_query.from_user.id} elimin√≥ el anuncio {listing_id}.")
    
    # Despu√©s de eliminar, mostrar mis anuncios o men√∫ principal
    await show_my_listings(callback_query, state) # Intenta mostrar —Å–ø–∏—Å–æ–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏–π

@dp.callback_query(F.data.startswith("confirm_delete_no:"))
async def cancel_delete_listing(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    listing_id = callback_query.data.split(":")[1]
    await state.clear()
    await callback_query.message.edit_text(f"üö´ Eliminaci√≥n del anuncio #{listing_id} cancelada.")
    logger.info(f"üö´ Usuario {callback_query.from_user.id} cancel√≥ eliminaci√≥n del anuncio {listing_id}.")
    await display_item_card(callback_query.from_user.id, listing_id, caller_is_edit=True) # Mostrar —Å–Ω–æ–≤–∞ –∫–∞—Ä—Ç–æ—á–∫—É


# ------------------------------ Establecer vigencia ------------------------------

@dp.callback_query(F.data.startswith("set_duration:"))
async def set_duration_start(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    listing_id = callback_query.data.split(":")[1]
    
    if listing_id not in listings or (listings[listing_id]['user_id'] != callback_query.from_user.id and callback_query.from_user.id != ADMIN_ID):
        await bot.send_message(callback_query.from_user.id, "‚ùó No tienes permiso para editar este anuncio.")
        return

    await state.update_data(selected_item_id=listing_id)
    await state.set_state(Form.set_duration)
    await callback_query.message.answer(
        f"Selecciona la nueva vigencia para el anuncio #{listing_id}:",
        reply_markup=get_expires_at_keyboard()
    )
    logger.info(f"‚û°Ô∏è Usuario {callback_query.from_user.id} inici√≥ configuraci√≥n de vigencia para anuncio {listing_id}.")

@dp.message(Form.set_duration, F.text.in_({"üìÖ 3 d√≠as", "üìÖ 5 d√≠as", "üóìÔ∏è Sin fecha de caducidad"}))
async def process_set_duration(message: Message, state: FSMContext):
    days = None
    if "3 d√≠as" in message.text:
        days = 3
    elif "5 d√≠as" in message.text:
        days = 5
    elif "Sin fecha de caducidad" in message.text:
        days = 0 # Usamos 0 para indicar sin expiraci√≥n
    else:
        # –≠—Ç–æ –Ω–µ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏–∑–æ–π—Ç–∏, —Ç–∞–∫ –∫–∞–∫ –º—ã –ø—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ F.text.in_
        await message.answer(
            "‚ùó Por favor, seleccione 'üìÖ 3 d√≠as', 'üìÖ 5 d√≠as' o 'üóìÔ∏è Sin fecha de caducidad'.",
            reply_markup=get_expires_at_keyboard()
        )
        return

    data = await state.get_data()
    listing_id = data.get('selected_item_id')

    if days == 0:
        listings[listing_id]['expires_at'] = None # –£–¥–∞–ª—è–µ–º —Å—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è
    else:
        expires_at = datetime.datetime.now() + datetime.timedelta(days=days)
        listings[listing_id]['expires_at'] = expires_at

    await save_listings()

    logger.info(f"‚úÖ Usuario {message.from_user.id} edit√≥ la vigencia del art√≠culo {listing_id}.")
    await display_item_card(message.from_user.id, listing_id, caller_is_edit=True)
    await state.clear()


@dp.message(Form.set_duration)
async def process_set_duration_invalid(message: Message):
    await message.answer(
        "‚ùó Por favor, seleccione 'üìÖ 3 d√≠as', 'üìÖ 5 d√≠as' o 'üóìÔ∏è Sin fecha de caducidad'.",
        reply_markup=get_expires_at_keyboard()
    )


# ------------------------------ Admin Panel ------------------------------

@dp.message(F.text == "üìä Admin Panel")
async def show_admin_panel(message: Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        await message.answer("‚ùó No tienes permiso para acceder al panel de administraci√≥n.")
        logger.warning(f"‚ö†Ô∏è Intento de acceso no autorizado al panel de administraci√≥n por el usuario {message.from_user.id}.")
        return
    
    await state.clear()
    
    total_users = len(users_data)
    total_listings = len(listings)
    active_listings = sum(1 for li in listings.values() if li.get('status') == 'active')

    message_text = (
        "üìä Panel de Administraci√≥n\n\n"
        f"Total de usuarios: {total_users}\n"
        f"Total de anuncios: {total_listings}\n"
        f"Anuncios activos: {active_listings}\n\n"
        "Seleccione una acci√≥n:"
    )

    admin_keyboard = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="üë• Ver Usuarios", callback_data="admin_view_users")],
        [InlineKeyboardButton(text="üìÑ Ver Todos los Anuncios", callback_data="admin_view_all_listings")],
        [InlineKeyboardButton(text="‚¨ÖÔ∏è Men√∫ Principal", callback_data="back_to_main")]
    ])
    await message.answer(message_text, reply_markup=admin_keyboard)
    logger.info(f"‚û°Ô∏è Usuario {message.from_user.id} accedi√≥ al Panel de Administraci√≥n.")

@dp.callback_query(F.data == "back_to_admin_panel")
async def back_to_admin_panel_callback(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    await show_admin_panel(callback_query.message, state)


@dp.callback_query(F.data == "admin_view_users")
async def admin_view_users(callback_query: CallbackQuery):
    if callback_query.from_user.id != ADMIN_ID:
        await callback_query.answer("‚ùó No tienes permiso.", show_alert=True)
        return
    await callback_query.answer()

    if not users_data:
        await callback_query.message.edit_text("No hay usuarios registrados a√∫n.")
        return

    message_text = "üë• Usuarios Registrados:\n\n"
    for user_id, info in users_data.items():
        username = info.get('username', 'N/A')
        full_name = info.get('full_name', 'N/A')
        first_access = info.get('first_access', 'N/A')
        message_text += (
            f"ID: <code>{user_id}</code>\n"
            f"Nombre: {escape(full_name)}\n"
            f"Usuario: @{escape(username) if username else 'N/A'}\n"
            f"Primer acceso: {first_access}\n\n"
        )
    
    await callback_query.message.edit_text(message_text, reply_markup=InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="‚¨ÖÔ∏è Volver al Panel Admin", callback_data="back_to_admin_panel")]
    ]))
    logger.info(f"‚û°Ô∏è Admin {callback_query.from_user.id} vio la lista de usuarios.")

@dp.callback_query(F.data == "admin_view_all_listings")
async def admin_view_all_listings(callback_query: CallbackQuery):
    if callback_query.from_user.id != ADMIN_ID:
        await callback_query.answer("‚ùó No tienes permiso.", show_alert=True)
        return
    await callback_query.answer()

    if not listings:
        await callback_query.message.edit_text("No hay anuncios publicados a√∫n.")
        return

    message_text = "üìÑ Todos los Anuncios:\n\n"
    keyboard = InlineKeyboardMarkup(inline_keyboard=[])

    sorted_listings = sorted(listings.items(), key=lambda item: item[1].get('published_at', ''), reverse=True)

    for listing_id, info in sorted_listings:
        title = escape(info.get('title', 'N/A'))
        status_icon = "üü¢" if info.get('status') == 'active' else "üî¥" 
        message_text += f"{status_icon} Anuncio #{listing_id}: {title} (Usuario: {info.get('user_id')})\n"
        keyboard.inline_keyboard.append([
            InlineKeyboardButton(text=f"Ver Anuncio #{listing_id}", callback_data=f"admin_view_listing:{listing_id}")
        ])
    
    keyboard.inline_keyboard.append([InlineKeyboardButton(text="‚¨ÖÔ∏è Volver al Panel Admin", callback_data="back_to_admin_panel")])

    await callback_query.message.edit_text(message_text, reply_markup=keyboard)
    logger.info(f"‚û°Ô∏è Admin {callback_query.from_user.id} vio todos los anuncios.")


@dp.callback_query(F.data.startswith("admin_view_listing:"))
async def admin_view_listing_details(callback_query: CallbackQuery):
    if callback_query.from_user.id != ADMIN_ID:
        await callback_query.answer("‚ùó No tienes permiso.", show_alert=True)
        return
    await callback_query.answer()
    listing_id = callback_query.data.split(":")[1]
    await display_item_card(callback_query.from_user.id, listing_id, is_admin_view=True)
    logger.info(f"‚û°Ô∏è Admin {callback_query.from_user.id} viendo detalles de anuncio {listing_id}.")


# ------------------------------ Navegaci√≥n general ------------------------------

@dp.callback_query(F.data == "back_to_main")
async def back_to_main_menu(callback_query: CallbackQuery, state: FSMContext):
    await callback_query.answer()
    await state.clear()
    await callback_query.message.edit_text(
        "Volviendo al men√∫ principal.",
        reply_markup=main_keyboard if callback_query.from_user.id != ADMIN_ID else get_main_keyboard_admin()
    )
    logger.info(f"‚û°Ô∏è Usuario {callback_query.from_user.id} volvi√≥ al men√∫ principal.")


@dp.message(F.text == "‚öôÔ∏è Configuraci√≥n")
async def show_settings(message: Message):
    await message.answer("üõ†Ô∏è Opciones de configuraci√≥n (funcionalidad no implementada): \n- Idioma \n- Notificaciones",
                         reply_markup=main_keyboard if message.from_user.id != ADMIN_ID else get_main_keyboard_admin())
    logger.info(f"‚û°Ô∏è Usuario {message.from_user.id} vio las opciones de configuraci√≥n.")


@dp.message()
async def handle_unprocessed(message: Message, state: FSMContext):
    if message.from_user.is_bot:
        logger.warning(f"‚ö†Ô∏è Ignorando mensaje no procesado de bot: user_id={message.from_user.id}")
        return
    logger.warning(f"‚ö†Ô∏è Mensaje no procesado del usuario {message.from_user.id}: '{message.text}'")
    current_state = await state.get_state()
    if current_state is None:
        await message.answer("‚ùó Acci√≥n no reconocida. Seleccione una opci√≥n del men√∫:", 
                             reply_markup=main_keyboard if message.from_user.id != ADMIN_ID else get_main_keyboard_admin())
    else:
        await message.answer(f"‚ùó Acci√≥n no reconocida. Por favor, contin√∫e con el proceso actual o use /cancel para reiniciar.")


# --- –î–û–ë–ê–í–õ–ï–ù–û/–ò–ó–ú–ï–ù–ï–ù–û –î–õ–Ø –í–ï–ë–•–£–ö–û–í –° AIOHTTP ---
async def on_startup_webhook(dispatcher: Dispatcher, bot: Bot):
    logger.info("üöÄ Bot is starting with webhooks (aiohttp)...")
    print(f"WEBHOOK_URL: {WEBHOOK_URL}")
    print(f"WEBAPP_HOST: {WEBAPP_HOST}")
    print(f"WEBAPP_PORT: {WEBAPP_PORT}")
    # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –≤–µ–±—Ö—É–∫ –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π
    await bot.delete_webhook(drop_pending_updates=True)
    # –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –Ω–æ–≤–æ–≥–æ –≤–µ–±—Ö—É–∫–∞
    await bot.set_webhook(WEBHOOK_URL, secret_token=WEBHOOK_SECRET) # <-- –≠–¢–ê –°–¢–†–û–ö–ê –ò–ó–ú–ï–ù–ï–ù–ê
    logger.info("‚úÖ Webhook set successfully.")
    if ADMIN_ID:
        try:
            await bot.send_message(ADMIN_ID, "‚úÖ –ë–æ—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ!")
        except Exception as e:
            logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –æ –∑–∞–ø—É—Å–∫–µ: {e}")

async def on_shutdown_webhook(dispatcher: Dispatcher, bot: Bot):
    logger.info("üî¥ Bot is shutting down, deleting webhook...")
    await bot.delete_webhook()
    logger.info("üóëÔ∏è Webhook deleted.")
    if ADMIN_ID:
        try:
            await bot.send_message(ADMIN_ID, "üî¥ –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω.")
        except Exception as e:
            logger.error(f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –æ–± –æ—Å—Ç–∞–Ω–æ–≤–∫–µ: {e}")


# –§—É–Ω–∫—Ü–∏—è main —Ç–µ–ø–µ—Ä—å –Ω–µ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è, —Ç–∞–∫ –∫–∞–∫ web.run_app() –±–ª–æ–∫–∏—Ä—É—é—â–∞—è
def main():
    logger.info("üöÄ Iniciando la funci√≥n principal...")
    # –ó–∞–≥—Ä—É–∂–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ (–Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å –∏—Ö —Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–º–∏ –∏–ª–∏ –≤—ã–∑–≤–∞—Ç—å asyncio.run –≤–Ω—É—Ç—Ä–∏)
    # –¢–∞–∫ –∫–∞–∫ load_user_data –∏ load_listings –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ, –∏—Ö –Ω—É–∂–Ω–æ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–æ –∑–∞–ø—É—Å–∫–∞ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞
    asyncio.run(load_user_data())
    asyncio.run(load_listings())

    # –°–æ–∑–¥–∞–µ–º –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ aiohttp
    app = web.Application()

    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤–µ–±—Ö—É–∫–æ–≤
    webhook_requests_handler = SimpleRequestHandler(
        dispatcher=dp,
        bot=bot,
        secret_token=WEBHOOK_SECRET # <-- –≠–¢–ê –°–¢–†–û–ö–ê –ò–ó–ú–ï–ù–ï–ù–ê
    )
    # –ü—É—Ç—å –¥–ª—è –≤–µ–±—Ö—É–∫–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º –∏ —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–∫–µ–Ω –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    webhook_requests_handler.register(app, path=f"/webhook/{WEBHOOK_SECRET}") # <-- –≠–¢–ê –°–¢–†–û–ö–ê –ò–ó–ú–ï–ù–ï–ù–ê

    # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ—É–Ω–∫—Ü–∏–∏ on_startup –∏ on_shutdown –¥–ª—è aiohttp –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
    app.on_startup.append(lambda app: on_startup_webhook(dp, bot))
    app.on_shutdown.append(lambda app: on_shutdown_webhook(dp, bot))

    # –ó–∞–ø—É—Å–∫–∞–µ–º –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    logger.info(f"üöÄ –ó–∞–ø—É—Å–∫–∞–µ–º –≤–µ–±-—Å–µ—Ä–≤–µ—Ä –Ω–∞ {WEBAPP_HOST}:{WEBAPP_PORT}")
    web.run_app(app, host=WEBAPP_HOST, port=WEBAPP_PORT)


if __name__ == '__main__':
    main() # main() —Ç–µ–ø–µ—Ä—å —Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è